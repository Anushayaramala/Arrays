Stack Data Structure
Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out.
 It means both insertion and deletion operations happen at one end only

LIFO(Last In First Out) Principle
Here are some real world examples of LIFO

Consider a stack of plates. When we add a plate, we add at the top. When we remove, we remove from the top.
A shuttlecock box (or any other box that is closed from one end) is another great real-world example of the LIFO (Last In, First Out) principle where do insertions and removals from the same end.

Basic Operations on Stack:
Push() to insert an element into the stack
pop() to remove an element from the stack
top() Returns the top element of the stack.
isEmpty() returns true if stack is empty else false.
isFull() returns true if the stack is full else false.

Stack using Array:
// Java program to create a stack with given capacity

class Stack { 
    int top, cap; 
    int[] a; 

    public Stack(int cap) { 
        this.cap = cap; 
        top = -1; 
        a = new int[cap]; 
    } 

    public boolean push(int x) { 
        if (top >= cap - 1) { 
            System.out.println("Stack Overflow"); 
            return false; 
        } 
        a[++top] = x; 
        return true; 
    } 

    public int pop() { 
        if (top < 0) { 
            System.out.println("Stack Underflow"); 
            return 0; 
        } 
        return a[top--]; 
    } 

    public int peek() { 
        if (top < 0) { 
            System.out.println("Stack is Empty"); 
            return 0; 
        } 
        return a[top]; 
    } 

    public boolean isEmpty() { 
        return top < 0; 
    } 
} 

public class Main { 
    public static void main(String[] args) { 
        Stack s = new Stack(5); 
        s.push(10); 
        s.push(20); 
        s.push(30); 
        System.out.println(s.pop() + " popped from stack"); 

        System.out.println("Top element is: " + s.peek()); 

        System.out.print("Elements present in stack: "); 
        while (!s.isEmpty()) { 
            System.out.print(s.peek() + " "); 
            s.pop(); 
        } 
    } 
}

Implementation using Dynamic Sized Array:
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> s = new ArrayList<>();

        // Push elements
        s.add(10);
        s.add(20);
        s.add(30);

        // Pop and print the top element
        System.out.println(s.get(s.size() - 1) + " popped from stack");
        s.remove(s.size() - 1);

        // Peek at the top element
        System.out.println("Top element is: " + s.get(s.size() - 1));

        // Print all elements in the stack
        System.out.print("Elements present in stack: ");
        while (!s.isEmpty()) {
            System.out.print(s.get(s.size() - 1) + " ");
            s.remove(s.size() - 1);
        }
    }
}

Comparison of the two Implementations
The first implementation should be preferred if we know capacity or have a close upper bound on number of elements.
The second one is simple and has amortized (average over n operations) time complexities as O(1) for push and pop.
However it can have a particular push and pop very costly.

Complexity Analysis:
Time Complexity:
push: O(1)
pop: O(1)
peek: O(1)
is_empty: O(1)
is_full: O(1)
Auxiliary Space: O(n), where n is the number of items in the stack.
Advantages of Array Implementation:
Easy to implement.
Memory is saved as pointers are not involved.
Disadvantages of Array Implementation:
It is not dynamic i.e., it doesnâ€™t grow and shrink depending on needs at runtime.

[But in case of dynamic sized arrays like vector in C++, list in Python, ArrayList in Java, stacks can grow and shrink with array implementation as well]. But with dynamic sized arrays, we get amortized time complexity as O(1), not the worst case. If we use linked list, we get worst case time complexities as O(1).
The total size of the stack must be defined beforehand.

Stack - Linked List Implementation:
To implement a stack using a singly linked list, we follow the LIFO (Last In, First Out) principle by inserting and removing elements from the head of the list, where each node stores data and a pointer to the next node.

The main advantage of using a linked list over arrays is that it is possible to implement a stack that can shrink or grow as much as needed.
Using an array will put a restriction on the maximum capacity of the array which can lead to stack overflow. Here each new node will be dynamically allocated. so overflow is not possible.
If we use built in dynamic sized arrays like vector in C++, list in Python or ArrayList in Java, we get automatically growing stack, but the worst case time complexity is not O(1) for push() and pop() as there might be a resizing step once in a while. With Linked List, we get worst case O(1).


class Node {
    int data;
    Node next;

    Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Stack using linked list
class Stack {
    Node head;

    Stack() {
        this.head = null;
    }

    // Check if stack is empty
    boolean isEmpty() {
        return head == null;
    }

    // Push an element onto stack
    void push(int new_data) {
        Node new_node = new Node(new_data);
        new_node.next = head;
        head = new_node;
    }

    // Pop the top element
    void pop() {
        if (isEmpty()) return;
        head = head.next;
    }

    // Return the top element
    int peek() {
        if (!isEmpty()) return head.data;
        return Integer.MIN_VALUE;
    }
}

public class Main {
    public static void main(String[] args) {
        Stack st = new Stack();

        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        System.out.println(st.peek());

        st.pop();
        st.pop();

        System.out.println(st.peek());
    }
}















